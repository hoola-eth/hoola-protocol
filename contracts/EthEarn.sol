// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

     /**
     * @notice Welcome to the LOOP
     * Documentation :
     * 
     * @author Ian Decentralize <idecentralize.eth>
     * 
     */


// OpenZeppelin Contracts library
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

// EthEarn NFT Contract Interface
import "./interfaces/INFTVault.sol";


contract EthEarn is Initializable, ERC20Upgradeable, AccessControlUpgradeable, PausableUpgradeable {
    using SafeMathUpgradeable for uint;
        
    address private admin;                        // owner of the contract (Gnosis Until Gov If ever)                
    uint256 public loopFees;                      // fee for the loop                
    uint256 public loopLoanFees;                  // fees in base 3  800 = 0.08%                     
    string public version;                        // version

    address ETHER;                                // 0x0000...
    address ETHERBalance;                         // ethBalanceTracker
    bytes32 NFT_CONTRACT_ROLE;                    // Role for NFT contract Owned by the LOOP
                              
    bool Loan;
    uint256 loanVaulId;
    address LoanedAsset;
    uint256 LoanedAmount;
    uint256 balanceBeforeLoan;
    
    uint256 public vaultCounter;
  
    mapping(uint256 => _NftVault) public nftVaults;
    struct _NftVault {
        uint256 id;
        address vaultAddress;
        bool active;
    }

    mapping(address => bool) public loopNftOwners;
    event NftSold(address user, uint256 id);
    /**
     * @notice CUMMULATED FEES
     * 
     * The Fees generated by the NFT Loans adds to the pool interest
     * The fees Generate by the Loop goes to the Reward pool
     */

    mapping(address => uint256) public loopCumulatedFees;     // for users 
    /**
     * Asset => User => Amount
     *
     */
    mapping(address => mapping(address => uint256)) public loopBalance;
    mapping(address => mapping(address => uint256)) public loopOrderBalance;


    mapping(address => bool) public authorized;
    mapping(uint256 => _Assets) public authorizedAssets;
    uint256 public assetCount;
    struct _Assets{
        uint256 id;
        address assetAddress;
    }
    uint256 public orderCount;
    mapping(uint256 => _Order) public orders;
   
    struct _Order{
        uint256 id;
        address creator;        // order creator
        address creatorAsset;   // providing asset
        uint256 creatorAmount;  // providing amount
        address askingAsset;    // asking asset
        uint256 askingAmount;   // asking amount
        uint256 askingFilled;   // filled asking amount 
        uint256 blockNum;       // Block number of the purchased amount.
        bool active;            // if order can be interacted with
        bool swap;              // if order, when filled, redeploys w/assets reversed
     }


    event OrderCreation (
        uint256 id,
        address creator,
        address creatorAsset, 
        uint256 creatorAmount, 
        address askingAsset,
        uint256 askingAmount, 
        uint256 blockNum, 
        bool swap
    );

    event OrderLiquidityUpdate (
        uint256 orderId,
        address creatorAsset,
        uint256 creatorAmount, 
        address askingAsset,
        uint256 askingAmount
    );


    // the only way to take funds in and out
    event Deposit(address asset, uint256 amount);                        
    event Withdraw(address asset, uint256 amount);
    
    
    // events
    event Trade(address user, address asset, uint256 amount);
    event Looped(address user, uint256 loopCount);

    function initialize(
        string memory _name,         
        string memory _symbol,       
        uint256 _fees,               
        address _admin
    ) public virtual initializer {
        __Pausable_init();
        __AccessControl_init();
        __ERC20_init(_name, _symbol);
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        admin = _admin;
        version = '1.0';
        loopFees = _fees;
        ETHER = address(0);
        
    }

    ///////////////////////////////////////////////////////
    // DEPOSIT 
    //
    /// @notice Deposit Funds
    /// @param creatorAsset The asset deposited
    /// @param creatorAmount The amount deposited
    /// THIS IS THE ONLY WAY IN
    function deposit(address creatorAsset, uint256 creatorAmount) public payable whenNotPaused {
        require(authorized[creatorAsset],'Unauthorized');
        uint256 balanceBefore;
        uint256 balanceAfter;
        if(creatorAsset == ETHER){
            require(creatorAmount == msg.value,'deposit: ensure you sent eth');
            loopBalance[ETHER][msg.sender] = loopBalance[ETHER][msg.sender].add(msg.value);

        }else{
            ERC20Upgradeable asset = ERC20Upgradeable(creatorAsset);
            balanceBefore = asset.balanceOf(address(this));
           // require(asset.allowance(msg.sender, address(this)) >= creatorAmount, 'deposit: increase allowance');  The UI will do it otherwise you know what your doing.
            require(asset.transferFrom(msg.sender, address(this), creatorAmount), 'deposit: transfer failed');
            balanceAfter = asset.balanceOf(address(this));
            require(balanceAfter.sub(balanceBefore) == creatorAmount, 'deposit: ensure you sent enough');
            loopBalance[address(asset)][msg.sender] = loopBalance[address(asset)][msg.sender].add(creatorAmount);
        }

        emit Deposit(creatorAsset, creatorAmount);
    }

    ///////////////////////////////////////////////////
    // WITHDRAW
    //
    /// @notice Withdraw Funds
    /// @param creatorAsset The asset deposited
    /// @param creatorAmount The amount deposited
    /// ONLY WAY OUT
    function withdraw(address creatorAsset, uint256 creatorAmount) public payable whenNotPaused {
        require(authorized[creatorAsset],'withdraw: unauthorized asset');
        require(availableBalance(creatorAsset,msg.sender) >= creatorAmount, 'withdraw: insufficient balance');
        uint256 balanceBefore;
        uint256 balanceAfter;
        if(creatorAsset == ETHER){
            balanceBefore = address(this).balance;
            loopBalance[ETHER][msg.sender] = loopBalance[ETHER][msg.sender].sub(creatorAmount);
            payable(msg.sender).transfer(creatorAmount); 
            balanceAfter = address(this).balance;
        }else{
            ERC20Upgradeable asset = ERC20Upgradeable(creatorAsset);
            balanceBefore = asset.balanceOf(address(this));
            require(loopBalance[address(asset)][msg.sender].sub(loopOrderBalance[address(asset)][msg.sender]) >= creatorAmount, 'withdraw: assets tied to an order'); // available balance
            require(asset.transfer(msg.sender, creatorAmount), 'withdraw: asset transfer failed');
            balanceAfter = asset.balanceOf(address(this));
            loopBalance[address(asset)][msg.sender] = loopBalance[address(asset)][msg.sender].sub(creatorAmount);
        }
        require (balanceBefore.sub(balanceAfter) == creatorAmount,'withdraw: insufficient balance' );
        emit Withdraw(creatorAsset, creatorAmount);
    }



    ///////////////////////////////////////////////////////
    //  CREATE ORDER/LIQUIDITY                                    
    //
    /// @notice create a new order
    /// @param creatorAsset The asset deposited
    /// @param creatorAmount The amount deposited
    /// @param askingAsset The asset wanted
    /// @param askingAmount The amount wanted
    /// @param swap The order will earn by being trade back and forward when set to true
    /// THE FUND SHOULD ALREADY BE IN THE CONTRACT
    function createLoopOrder(
        address creatorAsset, 
        uint256 creatorAmount, 
        address askingAsset, 
        uint256 askingAmount, 
        bool swap
    ) public payable whenNotPaused returns (uint256 orderId) {
        require(authorized[creatorAsset],'createLoopOrder: unauthorized asset');
        require(creatorAsset != askingAsset,'createLoopOrder: same asset');
        require(creatorAmount > 0 && askingAmount > 0,'createLoopOrder: zero amount');
        ERC20Upgradeable asset = ERC20Upgradeable(creatorAsset);
        require(availableBalance(creatorAsset, msg.sender) >= creatorAmount, 'createLoopOrder: insufficient balance');
        loopOrderBalance[address(asset)][msg.sender] = loopOrderBalance[address(asset)][msg.sender].add(creatorAmount);
        _Order storage order = orders[orderCount];
        
        order.id = orderCount;
        order.creator = msg.sender;
        order.creatorAsset = creatorAsset;
        order.creatorAmount = creatorAmount;
        order.askingAsset = askingAsset;
        order.askingAmount = askingAmount;
        order.blockNum = block.number;
        order.active = true;
        order.swap = swap;
        
        orderCount = orderCount.add(1);
        emit OrderCreation(orderCount, msg.sender, creatorAsset, creatorAmount, askingAsset, askingAmount, block.number, swap);
        return orderCount;
    }


    /**
     * @notice adjust details of the order
     * @param orderId order to adjust
     * @param creatorAsset The creator Amount
     * @param creatorAmount The amount to subtract/add to creatorAmount
     * @param askingAsset The amount to subtract/add to askingAmount
     * @param askingAmount The amount to subtract/add to askingAmount
     
     * Note
     * if filled partially:
     * - not payable
     * - will revert on partiall and swap
     * - allow decrease liquidity & if reaches askingFilled, complete order or swap
     * - cannot decrease askingAmount below whats already filled
     */

   ///////////////////////////////////////////////////////
   //           UpdateOrder
   //
   
    function updateLoopOrderLiquidity(
        uint256 orderId,                     
        address creatorAsset, 
        uint256 creatorAmount, 
        address askingAsset, 
        uint256 askingAmount
    ) public whenNotPaused {
        require(authorized[creatorAsset],'Unauthorized');
        require(orderId >= orderCount, "Inexistant order");
        _Order storage order = orders[orderId];
        require(order.creator == msg.sender, 'Not order creator');
        require(!order.swap && !(order.askingFilled == 0),'updateLoopOrderLiquidity: partial swap is not updateable');                          
          /// SAME ASSET CASE
          if(order.creatorAsset == creatorAsset){
            // SAME AMMOUNT
            if(order.creatorAmount == creatorAmount){
               // change asking price (optional)
               if(order.askingAsset != askingAsset){order.askingAsset = askingAsset;}                            // update asking asset if not equal
               if(order.askingAmount != askingAmount){order.askingAmount = askingAmount;}                        // update asking amount if not equal
               emit OrderLiquidityUpdate(orderId, creatorAsset, creatorAmount, askingAsset, askingAmount);
               return;
               
            }else{
                // CHANGE LIQUIDITY AMOUNT
                 if(order.creatorAmount > creatorAmount){
                     // ADD
                     require(availableBalance(order.creatorAsset, msg.sender) >= creatorAmount, 'Available Balance?');
                     // add to the orderBookBalance
                     loopOrderBalance[order.creatorAsset][msg.sender] = loopOrderBalance[order.creatorAsset][msg.sender].add(creatorAmount.sub(order.creatorAmount));
                 }else{
                     //REMOVE
                    loopOrderBalance[order.creatorAsset][msg.sender] = loopOrderBalance[order.creatorAsset][msg.sender].sub(order.creatorAmount.sub(creatorAmount));
                 }
                // change asking price (optional)
                if(order.askingAsset != askingAsset){order.askingAsset = askingAsset;}                // update unequal asking asset
                if(order.askingAmount != askingAmount){order.askingAmount = askingAmount;}            // update unequal asking amount
                emit OrderLiquidityUpdate(orderId, creatorAsset, creatorAmount, askingAsset, askingAmount);
               return;
            }
          } 
          // DIFFERENT ASSET CASE      
         else{
             // verify funds are in the orderBook before unlocking
             require(loopOrderBalance[order.creatorAsset][msg.sender] >= order.creatorAmount,'updateLoopOrderLiquidity: insufficient balance');
             loopOrderBalance[order.creatorAsset][msg.sender] = loopOrderBalance[order.creatorAsset][msg.sender].sub(order.creatorAmount);
             // unlocked previous funds
             // require new asset funds
             require(availableBalance(creatorAsset, msg.sender) >= creatorAmount, 'updateLoopOrderLiquidity: not enough available balance');
             order.creatorAsset = creatorAsset;
             // update the amount for the new liquidity (optional)
            if(order.creatorAmount != creatorAmount){order.creatorAmount = creatorAmount;}  
            // change asking price (optional)
            if(order.askingAsset != askingAsset){order.askingAsset = askingAsset;}                // update asking asset if not equal
            if(order.askingAmount != askingAmount){order.askingAmount = askingAmount;}            // update asking amount if not equal
            emit OrderLiquidityUpdate(orderId, creatorAsset, creatorAmount, askingAsset, askingAmount);
             return;

         }
 
        
    }

    ///////////////////////////////////////////////////////
    //                REMOVE LIQUIDITY
    //

    function removeLoopOrderLiquidity(
        uint256 orderId                  
    ) public whenNotPaused {
       
    }
   ///////////////////////////////////////////////////////
   //            ======> LOOP HERE <=====
   //

    /// @notice Fill one or more orders
    /// @param fillIds array of all the orders we fill
    /// @param fillAmounts array of all the amounts we fill
    /// @param numOfOrders awarness of the loop length
    /// @param skipable allow to skip order
    /// @param compLoanAmount Asset to borrow 
    /// @param compLoanAsset Asset to borrow
    function loop(
        uint256[] memory fillIds, 
        uint256[] memory fillAmounts, 
        uint256 numOfOrders, 
        bool skipable,
        uint256 NFTvaultId,
        uint256 compLoanAmount,
        address compLoanAsset
    ) public whenNotPaused{
        // check awareness
        require(numOfOrders <= orderCount && numOfOrders > 0,'loop: invalid order count');
        require(fillIds.length > 0 && fillIds.length  == numOfOrders,'loop: invalid order count');

       // TO DO BEFORE LOOP 
       if(compLoanAmount > 0){

            _NftVault memory _nftVault = nftVaults[NFTvaultId];
            require(_nftVault.active,'Vault Inactive');
            INFTVault loopNft = INFTVault(_nftVault.vaultAddress);
            loopNft._borrow(compLoanAmount,compLoanAsset);
            loanVaulId = NFTvaultId;
            Loan = true;
            LoanedAmount = compLoanAmount;
            LoanedAsset = compLoanAsset;
       }
       // Start the loop
       _loopConstruct(fillIds, fillAmounts, skipable);
    }

    
    /// @notice _tradeConstruct internal loop to fill multiple orders
    /// @param _orderIds all id of the orders to be filled, should contain an extra one for slippage
    /// @param _fillAmounts all Amount to be filled
    /// @param _skipable will let the loop skip an order that is no longer available
    
    function _loopConstruct(
        uint256[] memory _orderIds, 
        uint256[] memory _fillAmounts, 
        bool _skipable
    ) internal {
        uint256 fillAmount;   
        uint256 counter;

        for (counter == 0; counter < _orderIds.length; counter++) {
            // load from memory
            _Order memory _order = orders[_orderIds[counter]];
            //check if order is active
            if (!_order.active) {
                // revert if skipable is false
                require(_skipable, 'Unskipable Inactive');
                // ship to order
                counter = counter.add(1);
            } else {
                // we trade the active order 
                // check the amount filled
                  
                // if the taker fully fill the order
                if (_order.askingAmount.sub(_order.askingFilled) == _fillAmounts[counter]) {
                    
                    //if the order is partially filled
                    if (_order.askingFilled>0) {
                        // the amount is what's left
                        fillAmount = _order.askingAmount.sub(_order.askingFilled);
                    }
                    // otherwise it's the full amount
                    fillAmount = _order.askingAmount;    
                }
                // the order is partially filled
                else if (_order.askingAmount.sub(_order.askingFilled) > _fillAmounts[counter]) {  
                    // if we partialy fill an order
                    fillAmount = _fillAmounts[counter];
                }

                _loopTrade(_orderIds[counter],fillAmount);
                counter += 1;
            } // next order
                
        } // end of the loop 

          // IF WE HAD A LOAN WITH NFT VAULTS
             if(Loan){

                 ERC20Upgradeable asset = ERC20Upgradeable(LoanedAsset);
                  _NftVault memory _nftVault = nftVaults[loanVaulId];
                   require(_nftVault.active,'Vault Inactive');
                   INFTVault loopNft = INFTVault(_nftVault.vaultAddress);
                   // reset loan
                   Loan = false;
                   asset.approve(address(loopNft),loopNft.getLoanFees(LoanedAmount, msg.sender));
                   require(loopNft._repay() == 0);
             }
             
             emit Looped(msg.sender,counter);
    }


     /// @notice execute a trade single trade could/should be refactored in multiple small functions

    function _loopTrade(uint256 orderId, uint256 askingFilled) internal {
         _Order storage _order = orders[orderId];

         // require an active balance not in trade.
         require(loopBalance[_order.askingAsset][msg.sender].sub(loopOrderBalance[_order.askingAsset][msg.sender]) >= askingFilled,'_loopTrade: funds are unavailable');

         // if we close the order 
         if (_order.askingAmount.sub(_order.askingFilled) == askingFilled) {

             // if it's Not swapable
            if (!_order.swap) {


               ////////////////// FUNCTION TO FILL NON SWAPABLE
                loopBalance[_order.askingAsset][_order.creator] = loopBalance[_order.askingAsset][_order.creator]
                    .add(askingFilled.sub(getLoopFees(askingFilled, _order.creator)));
                loopCumulatedFees[_order.askingAsset] = loopCumulatedFees[_order.askingAsset].add(getLoopFees(askingFilled,_order.creator));
                loopOrderBalance[_order.creatorAsset][_order.creator] = loopOrderBalance[_order.creatorAsset][_order.creator].sub(_order.creatorAmount);

                loopBalance[_order.askingAsset][msg.sender] = loopBalance[_order.askingAsset][msg.sender].sub(_order.askingAmount);
                loopBalance[_order.creatorAsset][msg.sender] = loopBalance[_order.creatorAsset][msg.sender]
                    .add(_order.creatorAmount.sub(getLoopFees(_order.creatorAmount, msg.sender)));
                loopCumulatedFees[_order.askingAsset] = loopCumulatedFees[_order.askingAsset].add(getLoopFees(askingFilled, _order.creator));
                _order.active == false;
               ///////////////////////////////////////////////////////



            } else {

                //////////// FUNCTION TO FULLY FILL A SWAPABLE ORDER
                address swap_creatorAsset = _order.askingAsset;
                address swap_askingAsset = _order.creatorAsset;
                uint256 swap_creatorAmount = _order.askingAmount;
                uint256 swap_askingAmount = _order.creatorAmount;
                    
                // ajust creator orderbalance in taker asset
                loopOrderBalance[_order.askingAsset][_order.creator] = loopOrderBalance[_order.askingAsset][_order.creator].add(askingFilled);
                // we also ajust the balance of creator 
                loopBalance[_order.askingAsset][_order.creator] = loopBalance[_order.askingAsset][_order.creator].add(askingFilled);
                
                // we ajust the creator orderBalance in creator asset. no fees here because the amount are fixed on this order unless updated.
                // fully filled but may be partial
                loopOrderBalance[_order.creatorAsset][_order.creator] = loopOrderBalance[_order.creatorAsset][_order.creator]
                    .sub(_order.creatorAmount.sub(_order.askingFilled));

                // the creator of a swap order get's deducted the creatorAmount but not the generated fees off is balance so the profit is in the balance
                loopBalance[_order.creatorAsset][_order.creator] = loopBalance[_order.creatorAsset][_order.creator]
                    .sub(_order.creatorAmount.sub(_order.askingFilled)
                        .sub(getLoopFees(_order.creatorAmount,msg.sender))
                    );
                
                // adjust the balance of the taker
                loopBalance[_order.askingAsset][msg.sender] = loopBalance[_order.askingAsset][msg.sender].sub(_order.askingAmount);
                loopBalance[_order.creatorAsset][msg.sender] = loopBalance[_order.creatorAsset][msg.sender]
                    .add(_order.creatorAmount.sub(_order.askingFilled)
                    .sub(getLoopFees(_order.creatorAmount, msg.sender))
                );
                
                // swapable order
                loopCumulatedFees[_order.creatorAsset] = loopCumulatedFees[_order.creatorAsset].add(getLoopFees(_order.creatorAmount,msg.sender));
                
                // inverse the order.
                _order.creatorAsset = swap_creatorAsset;
                _order.askingAsset = swap_askingAsset;
                _order.creatorAmount = swap_creatorAmount;
                _order.askingAmount = swap_askingAmount;

                //////////////////////////////////////////////////////////

            }  
        // if we partially fill an order
        } else if (_order.askingAmount.sub(_order.askingFilled) > askingFilled) {

            /////////////////////////////////////////// FUNCTION TO FILL A PARTIAL ORDER
           

            // check if partial swapable? 
            uint256 fillRatio = quotient(askingFilled, _order.askingAmount.sub(_order.askingFilled), 18);
            uint256 creatorPartialAmount = fillRatio.mul(_order.creatorAmount); 
            // filler balance
            loopBalance[_order.askingAsset][msg.sender] = loopBalance[_order.askingAsset][msg.sender].sub(askingFilled);
            //taker always pay his fees
            loopBalance[_order.creatorAsset][msg.sender] = loopBalance[_order.creatorAsset][msg.sender]
                .add(creatorPartialAmount.sub(getLoopFees(creatorPartialAmount,msg.sender)));
            // creator balance and orer balance 
            loopBalance[_order.askingAsset][_order.creator] = loopBalance[_order.askingAsset][_order.creator].add(askingFilled);
            // update partially 
            loopOrderBalance[_order.creatorAsset][_order.creator] = loopOrderBalance[_order.creatorAsset][_order.creator].sub(creatorPartialAmount);
            
            _order.askingFilled = _order.askingFilled.add(askingFilled);
            if (_order.swap) {
                // we know it's partial remains active
                loopBalance[_order.creatorAsset][_order.creator] = loopBalance[_order.creatorAsset][_order.creator]
                    .sub(creatorPartialAmount.sub(getLoopFees(creatorPartialAmount, msg.sender)));
                loopOrderBalance[_order.askingAsset][_order.creator] = loopOrderBalance[_order.askingAsset][_order.creator].add(askingFilled);
            }
            else {
                // not a swap but partially filled 
                // deduct the balance of the amount
                loopBalance[_order.creatorAsset][_order.creator] = loopBalance[_order.creatorAsset][_order.creator].sub(creatorPartialAmount);
                // the order balance adjusts
                loopOrderBalance[_order.askingAsset][_order.creator] = loopOrderBalance[_order.askingAsset][_order.creator].add(askingFilled);
            }
            ///////////////////////////////////////////////////////////////////////////////
         }

    }


   ///////////////////////////////////////////////////////
   //              BUY A VAULT NFT
   //

    /// @notice returns a quotient
    /// @dev this function assumed you checked the values already 
    /// @param vaultId vault id

   
    function buyVaultNft(uint256 vaultId, address to) public payable {
    _NftVault memory nftVault = nftVaults[vaultId];
    require(nftVault.active,'buyVaultNft: inactive vault');

    INFTVault loopNft = INFTVault(nftVault.vaultAddress);

    loopNft._getNFT{value:msg.value}(to);

    emit NftSold(msg.sender, vaultId);
    }



    ///////////////////////////////////////////////////////
    //              MATH FUNCTION
    //
    /// @notice returns a quotient
    /// @dev this function assumed you checked the values already 
    /// @param numerator the amount filled
    /// @param denominator the amount in order 
    /// @param precision the decimal places we keep
    /// @return _quotient
   
    function quotient(
        uint256 numerator, 
        uint256 denominator, 
        uint256 precision
    ) pure internal returns(uint256 _quotient) {
        uint256 _numerator  = numerator * 10 ** (precision+1);
        _quotient =  ((_numerator / denominator) + 5) / 10;
        return (_quotient);
    }




    /// @notice Get Loop Fees
    /// @param amount the amount we to take the fees on
    /// @param user the account that is paying the fees

    function getLoopFees(uint256 amount, address user) public view returns(uint256){                                                               
         uint256 fees;
        if(loopNftOwners[user]){
           fees = loopFees.div(2);
        }else{
            fees = loopFees;
        }
        return (amount.div(10000)).mul(fees);
    }

  
    /// @notice AVAILABLE BALANCE
    /// @param asset the asset
    /// @param user the account 
    /// @return the loopBalance - loopOrderBalance

    function availableBalance(address asset, address user) public view returns (uint256) {
        return loopBalance[asset][user].sub(loopOrderBalance[asset][user]);
    }


    ///////////////////////////////////////////////////////
    //              Administrative / GOV
    //
    /// @notice AVAILABLE BALANCE
    /// @param vaultAddress the nft contract vault address
   function addNFTVault(address vaultAddress) public {
    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender),"addNFTVault: admin only");
    
    vaultCounter = vaultCounter.add(1); 
    _NftVault storage _nftVault = nftVaults[vaultCounter];
    _nftVault.id = vaultCounter;
    _nftVault.vaultAddress = vaultAddress;
    _nftVault.active = true;
     

   }

    /// @notice Register an asset
    /// @param asset the nft contract vault address
    function registerAsset(address asset) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender),"registerAsset: admin only");
        
        require(!authorized[asset],'Already regsitered');
        authorized[asset] = true;
        _Assets storage _asset = authorizedAssets[assetCount];
        _asset.id = assetCount;
        _asset.assetAddress = asset;
        assetCount = assetCount.add(1);
    }

    /// @notice THIS VAULT ACCEPT ETHER

    receive() external payable {
        // nothing to do
    }    

    /// @notice SECURITY.

    /// @notice pause or unpause.
    /// @dev Security feature to use with Defender

    function pause() public whenNotPaused{
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "pause: admin only");
        _pause();
    }
    
    function unpause() public whenPaused{
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "unpause: admin only");
        _unpause();
    }

}